---
title: Software Tester
date: '2025-03-20'
tags: ['Software', 'Tester']
draft: false
summary:  Knowledge about Software Tester
---
# Basic of Software Testing
## 1. Understand Purpose of Testing

- Ensures software meets requirements.
- Detects defects early to reduce costs.
- Improves software reliability and performance.

## 2. Principles of Software Testing

- Testing shows defects, not absence of defects.
- Exhaustive testing is impossible.
- Early testing saves time and cost.
- Defects tend to cluster.
- Pesticide paradox: Repeating same tests won't find new bugs.
- Testing is context-dependent.
- Absence-of-errors fallacy: A bug-free product may still fail.

## 3. Difference between Error, Fault and Failure

- Error: Mistake made by a developer.
- Fault (Bug): Defect in code.
- Failure: When a fault is executed, causing incorrect behavior.

## 4. White Box and Black Box Testing

- White Box: Internal logic and structure testing (unit testing, code coverage).
- Black Box: Testing without knowing internal structure (functional testing).

## 5. Levels of Testing

- Unit Testing: Tests individual components.
- Integration Testing: Ensures different parts work together.
- System Testing: Tests entire system against requirements.
- Acceptance Testing: Verifies if software meets business needs.

## 6. Software Development Life Cycle (SDLC)

- Phases: Requirement Analysis -> Design -> Implementation -> Testing -> Development -> Maintainance.
- Models: Waterfall, Agile, V-Model, Spiral.

# Testing Design Techniques
## 1. Use Case Testing
- Tests real-world user scanarios.
- Ensures business processes function as expected.
## 2. Decision Table Testing
- Uses tables to define different input conditions and expected outputs.
## 3. State Transition Testing
- Evaluates how a system behaves when it changes states.
- Useful for workflows, login/logout, etc.

## 4. Boundary Value Analysis
- Tests values at boundaries (e.g., min/max).
- Example: If input range is 1-100, test 0, 1, 100, 101.

## 5. Equivalence Partioning
- Divides input data into valid/invalid groups.
- Reduces test cases while ensuring coverage.

## 6. Error Guessing
- Uses experience to predict potential errors.
- Example: Entering special characters in a name field.

# Types of Software Testing
## 1. Functional Testing
- Verifies specific software functions.
- Example: Login, payment processing, form submission.
## 2. Non-Functional Testing
- Tests performance, usability, security, etc.
## 3. Regresstion Testing
- Ensures new changes don't break existing features.
## 4. Smoke Testing
- Initial test to check if major features work.
## 5. Load Testing
- Assesses system performance under expected load.
## 6. Performance Testing
- Evaluates speed, stability, and scalability.

# Automated Testing
## 1. Introduction to Automation Testing
- Uses tools/scripts to execute test cases.
- Reduces manual effort and increases efficiency.
## 2. Choosing the Right tools for Automation Testing
- Selenium, JUnit, TestNG, Cypress, Playwright, etc.
## 3. Planning, Design and Development
- Define automation scope, design test scripts, and set up frameworks.
## 4. Test Execution and Management
- Running scripts, managing results, handling failures.
## 5. Debugging
- Identifying and fixing issues in automation scripts.

# Test Management
## 1. Concept and Test Planning
- Defines testing scope, objectives, schedule, and resources.
## 2. Configuring and Using Test Management Tools
- JIRA, TestRail, Zephyr, HP ALM, etc.
## 3. Test Monitoring and Control
- Tracking test progress and adjusting strategies.
## 4. Test Estimation
- Predicting time, effort and cost for testing
## 5. Risk Management in Testing
- Identifying risks, assessing impact, and mitigation strategies.
## 6. Reporting Test Status
- Test reports, defect reports, dashboards.

# Manual Testing
## 1. Introduction to Manual Testing
