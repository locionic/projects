---
title: Software Tester
date: '2025-03-20'
tags: ['Software', 'Tester']
draft: false
summary:  Knowledge about Software Tester
---
# Basic of Software Testing
## 1. Understand Purpose of Testing

- Ensures software meets requirements.
- Detects defects early to reduce costs.
- Improves software reliability and performance.

## 2. Principles of Software Testing

- Testing shows defects, not absence of defects.
- Exhaustive testing is impossible.
- Early testing saves time and cost.
- Defects tend to cluster.
- Pesticide paradox: Repeating same tests won't find new bugs.
- Testing is context-dependent.
- Absence-of-errors fallacy: A bug-free product may still fail.

## 3. Difference between Error, Fault and Failure

- Error: Mistake made by a developer.
- Fault (Bug): Defect in code.
- Failure: When a fault is executed, causing incorrect behavior.

## 4. White Box and Black Box Testing

- White Box: Internal logic and structure testing (unit testing, code coverage).
- Black Box: Testing without knowing internal structure (functional testing).

## 5. Levels of Testing

- Unit Testing: Tests individual components.
- Integration Testing: Ensures different parts work together.
- System Testing: Tests entire system against requirements.
- Acceptance Testing: Verifies if software meets business needs.

## 6. Software Development Life Cycle (SDLC)

- Phases: Requirement Analysis -> Design -> Implementation -> Testing -> Development -> Maintainance.
- Models: Waterfall, Agile, V-Model, Spiral.

# Testing Design Techniques
## 1. Use Case Testing
- Tests real-world user scanarios.
- Ensures business processes function as expected.
## 2. Decision Table Testing
- Uses tables to define different input conditions and expected outputs.
## 3. State Transition Testing
- Evaluates how a system behaves when it changes states.
- Useful for workflows, login/logout, etc.

## 4. Boundary Value Analysis
- Tests values at boundaries (e.g., min/max).
- Example: If input range is 1-100, test 0, 1, 100, 101.

## 5. Equivalence Partioning
- Divides input data into valid/invalid groups.
- Reduces test cases while ensuring coverage.

## 6. Error Guessing
- Uses experience to predict potential errors.
- Example: Entering special characters in a name field.

# Types of Software Testing
## 1. Functional Testing
- Verifies specific software functions.
- Example: Login, payment processing, form submission.
## 2. Non-Functional Testing
- Tests performance, usability, security, etc.
## 3. Regresstion Testing
- Ensures new changes don't break existing features.
## 4. Smoke Testing
- Initial test to check if major features work.
## 5. Load Testing
- Assesses system performance under expected load.
## 6. Performance Testing
- Evaluates speed, stability, and scalability.

# Automated Testing
## 1. Introduction to Automation Testing
- Uses tools/scripts to execute test cases.
- Reduces manual effort and increases efficiency.
## 2. Choosing the Right tools for Automation Testing
- Selenium, JUnit, TestNG, Cypress, Playwright, etc.
## 3. Planning, Design and Development
- Define automation scope, design test scripts, and set up frameworks.
## 4. Test Execution and Management
- Running scripts, managing results, handling failures.
## 5. Debugging
- Identifying and fixing issues in automation scripts.

# Test Management
## 1. Concept and Test Planning
- Defines testing scope, objectives, schedule, and resources.
## 2. Configuring and Using Test Management Tools
- JIRA, TestRail, Zephyr, HP ALM, etc.
## 3. Test Monitoring and Control
- Tracking test progress and adjusting strategies.
## 4. Test Estimation
- Predicting time, effort and cost for testing
## 5. Risk Management in Testing
- Identifying risks, assessing impact, and mitigation strategies.
## 6. Reporting Test Status
- Test reports, defect reports, dashboards.

# Manual Testing
## 1. Introduction to Manual Testing
- Testing without automation tools.
## 2. Types of Manual Testing
- Exploratory, Usability, Ad hoc, Accessibility.
## 3. Bug Life Cycle
- New -> Open -> Assigned -> Fixed -> Retested -> Verified -> Closed.
## 4. Bug Reporting Tools
- JIRA, Bugzilla, Redmine, Mantis.
## 5. Test Case Development
- Writing detailed test cases with inputs, expected results, and steps.
## 6. Use of Excel in Manual Testing
- Documenting test cases, bug tracking, data storage.

# Agile Testing
## 1. Principles of Agile Testing
- Testing integrated into development.
- Continuous feedback, fast iterations.
## 2. Agile Test Strategy
- Focuses on delivering working software quickly.
## 3. Agile Testing Quadrants
- Functional, Non-functional, Automation, Exploratory testing.
## 4. Role of a Tester in an Agile Team
- Works closely with developers, automates tests, writes test cases.
## 5. Testing Tools in Agile
- JIRA, Selenium, TestNG, Cucumber.
## 6. User Story Testing
- Verifying user stories meet acceptance criteria.

# Security Testing
## 1. Security Testing Concepts
- Ensures application is secure from threats.
## 2. Common Security Vulnerabilities
- SQL Injection, XSS, CSRF, Broken Authentication.
## 3. Risk Assessment
- Identifying and prioritizing risks.
## 4. Security Testing Tools and Techniques
- OWASP ZAP, Burp Suite, Metasploit.
## 5. Penetration Testing
- Simulating attacks to find vulnerabilities.
## 6. Vulnerability Scanning
- Automated scanning tools to detect security issues.

# Web Application Testing
## 1. Web Testing Strategies
- Ensuring UI/UX, performance, security and functionality.
## 2. Functional Web Testing
- Testing web page interactions, forms, authentication.
## 3. Performance Testing for Web Applications
- Load testing, stress testing.
## 4. Security Testing for Web Applications
- Testing for SQL Injection, XSS, CSRF, etc.
## 5. Load Testing for Web Applications
- Checking performance under high traffic.
## 6. Cross Browser Testing
- Ensuring compatibility across different browsers.

# Mobile Application Testing
## 1. Mobile Application Testing Strategies
- Testing across different OS, screen sizes, network conditions.
## 2. Functional Testing for Mobile Applications
- Checking mobile-specific features like gestures, push notifications.
## 3. Performance Testing for Mobile Applications
- Evaluating speed, memory usage, battery consumption.
## 4. Security Testing for Mobile Applications
- Identifying security loopholes in mobile apps.
## 5. Device and Platform Testing
- Ensuring compatibility across various devices.
## 6. Usability Testing for Mobile Applications
- Checking user-friendliness, responsiveness.

# API Testing
## 1. Introduction to APIs and API Testing
- Testing communication between software components.
## 2. REST and SOAP Web Services Testing
- Validating API requests, responses.
## 3. API Testing Tools
- Postman, SoapUI, JMeter.
## 4. Creating API Test Cases
- Writing test cases for status codes, authentication, response time.
## 5. Security Testing for APIs
- Checking for token validation, encryption, rate limiting.
## 6. Load Testing for APIs
- Simulating high traffic to assess performance.

# DevOps and Testing
## 1. Understanding DevOps
- Collaboration between dev and ops teams.
## 2. Role of a Tester in DevOps
- Automating tests, integrating with CI/CD.
## 3. Continuous Testing
- Running tests in a continuous integration pipeline.
## 4. DevOps Testing Tools
- Jenkins, Docker, Kubernetes.
## 5. Quality Gates in DevOps
- Ensuring code meets predefined quality standards.
## 6. Performance Tuning in DevOps
- Optimizing application and infrastructure performance.
