---
title: Fullstack Interview
date: '2025-03-20'
tags: ['Fullstack', 'Interview']
draft: false
summary: Top 50 Full Stack Developer Interview Questions 
---
# Beginner
## What is full-stack development?
**Full-stack development** refers to the practice of building and maintaining both the frontend and backend of a web application or web service. A full-stack developer works across all layers of the application, ensuring seamless functionality from the user interface to the server and database.

Key aspects of a full-stack development include:
- **Frontend Development**: involves creating the parts of the application that users interact with directly, such as buttons, forms, and layouts. Tools and technologies often used include **HTML, CSS, JavaScript**, and frameworks like React, ANgular, or Vue.js. This may also include building Progressive Web APps (PWAs) for enhanced user experiences.
- **Backend Development**: Focuses on server-side logic, databases and APIs that power the frontend. COmmon programming languages for backend development include **Python, Java, Node.js, PHP**.
- **Databases and Storage**: Managing data through relational databases (e.g., MySQL, PostgreSQL) or non-relational databases (e.g., MongoDB, Redis).
- **DevOps and Deployment**: Setting up hosting environments, CI/CD pipelines, and handling cloud services to deploy and maintain applications.

Full-stack developers are valued for their versatility and and ability to understand how different components of a web application interact, making them crucial for delivering well-rounded, functional products.

## Explain the difference between lcient-side and server-side programming
The **client-side** and **server-side** refer to two distinct parts of a **web application** that work together to deliver functionality to users. Understanding their roles is essential for building efficient and responsive applications.

### Client-side
- **What it ddoes**: this is the part of the application that runs in the user's browser. It handles user interfaces and teractions, allowing users to see and interact with the applictaion.
- ** Key characteristics:
  - Executes **JavaScript code** directly in the browser to handle tasks like form validation, animations and dynamic content updates (through DOM - updates)
  - Manages rendering of HTML and CSS for a seamless visual experience.
  - Often communicates with the server via **REST** (Representational State Transfer) APIs to fetch or send data asynchronously.
- **Examples**:
  - Clicking a button that triggers a JavaScript function to show a popup
  - Fetching additional items on a page using fetch() or axios without a full page reload.
### Server-side
- **What it does**: this part operates on the server and processes requests from the client, performing tasks like database queries, busniness logic and serving responses.
- **Key characteristics**:
  - Executes server-side programming languages like Python, Java or Node.js
  - Handles sensitive operations like authentication and data storage securely.
  - Sends data to the client in structured formats (e.g., JSON) via REST APIs for rendering
- **Examples:
  - Processing a login request by verifying credentials in a database.
  - Returning a list of products in JSON format for the client to display dynamically.
##  What is the purpose of HTML, CSS and JavaScript in web development?
- HTML: Defines the structure and content of a webpage.
- CSS: Styles the webpage (colors, layout, fonts).
- JavaScript: Adds interactivity and dynamic behavior to the webpage.
## What is a REST API, and why is it used?
A REST API (Representational State Transfer APplication Programming Interface) is a standarized way for applications to communicate over HTTP by following a set of principles. It allows clients (like web browsers or mobile apps) to interact with servers to perform operations like fetching or modifying data.
### Key features of a REST API:
1. Stateless Communication: each request from the client to the server must contain all the information needed for the server to process it with no reliance on stored session data.
2. Resource-Based: Data annd functionality are treated as "resources" accessed using endpoints (URLs).
  - Example: `/users` to get a list of users, `/users/1` to access a specific user.
3. HTTP methods: REST APIs use HTTP methods to define actions:
  - GET: Retrieve data
  - POST: create new resources
  - PUT: update existing resources
  - DELETE: Remove resources
4. Structured Responses: Data is typically returned in a lightweight format like JSON or XML
### Why is it used?
  - Interoperability: REST APIs enable communication between different systems and playforms, making them ideal for building web services.
  - Scalability: they are stateless, allowing them to handle more traffic with horizontal scaling.
  - Ease of use: clear structure and standard conventions make it easy for developers to understand and implement.
  - Flexibility: Suitable for a variety of clients, from web applications to mobile and IoT devices.
## Explain the difference between GET and POST HTTP methods
While there is no hard rule stating these methods need to be used in a very specific way, the currently accepted standard, says that:
- GET: Retrieves data from a server (read-only).
- POST: sends data to the server to create or update resources.
## How do you include CSS in an HTML document?
There are two main ways to include CSS into your HTML, you can either do it "inline" or you can do it with the "style" tag.

Inline: Add `style` directly in an HTML element.
```html
<p style="color: red;">Hello</p>
```
Internal: use a `<style>` tag in the `<head>`
```html
<style>
p { color: red; }
</style>
```
External: Link a CSS file using `<link>` in the `<head>`
```html
<link rel="stylesheet" hred="styles.css">
```
## What is the purpose of the div and span tags in HTML?
- `<div>`: this is block-level element that groups other block-level elements (layout or sections) together. It's quite useful for layout definition.
- `<span>`: This inline element is greate for grouping together other inline elements, such as text nodes. Because the `<span>` has no structural impact on the content when used, it's perfect for styling text (or even sections of a larger text) without visually affecting it (other than the actual CSS applied).
## What are CSS selectors, and can oyu name a few types?
CSS selectors are patterns used to select and style specific elements in an HTML document. They define which elements a set of CSS rules should apply to, making them a fundamental part of designing the appearance of web applications and user interfaces.

Why CSS selectors matter

Selectors allow you to target elements precisely, enabling you to control layout, colors, fonts, and other visual aspects of you website. They are essential for creating strucrued and maintainable CSS code.

There are different types of selectors, categorized based on what they target:
- Elements: These selectors reference a specific type of element, and affect all instances of that element throughout the page. Example: `p{}`
- Classes: these selectors only affect those elements that have a matching class. They're greate to target large groups of elements of the same type, without affecting the entire set. Example: `.my-class{}`
- ID: ID-level selectors affect only one element (as IDs can only be used on a single element). They're greate when you have a single element that breaks the pattern from the rest of the group. Example `#my-id{}`
- Attribute: Attribute-level selectors target elements based on the value of their attributes. They're greate for the cases where you have to dynamically highlight elements. Example: `[type="text"]{}`
- Descendant: Another way to target other elements is to target them based on the parent element. This method works with any combination of the above, so you can potentially target elements using a specific class that are descendants of an elements with a specific attribute value (or any other combination you can think of). Example: `div p {}`

When to use selectors:
- Use type selectors for global styling
- Use class selectors for reusable styles across multiple elements
- Use ID selectors sparingly for unique elements
- Combine selectors for granular control and better maintainability

CSS selectors give you the power to control every aspect of your web application's design, ensuring that your user interfaces are consistent, visually appealing, and responsive

## How does JavaScript manipulate the DOM?
JavaScript accesses and modifies the DOM using methods like:
- Get elements: `document.getElementById("id")`, `querySelector(".class")`.
- Modify content: `element.innerHTML = "New content"`.
- Change styles: `element.style.color = "blue"`.
- Add/remove elements: `appendChild()`, `removeChild()`.

## What is the difference between == and === in JavaScript?
- `==`: Compares values with each other directly, performing type conversion if required first (example: `'5' == 5` -> `true).
- `===`: This operator strictly compares values and types with each other. There is no type conversion performed with this operator. For example, if you try to compare a string and a number, the result will always be false no matter what: `'5' === 5` -> `false`.
## What is the difference between relational and non-relational databases?
- Relational: Stores data in structured tables with rows and columns (e.g., MySQL, PostgreSQL). Good for relationships and complex queries.
- Non-relational: Stores data in flexible formats like documents, key-value pairs, or graphs (e.g., MongoDB, Redis). Better for unstructured or hierarchical data.
## How would you handle user authentication in a web application?
There are many ways to handle authentication, from simple auth, all the way to oAuth. The right option depends on your particular business needs.

A classical example is using JWT for authenticating a website with a RESTful API using the following process:
1. Frontend: Present a login form to collect credentials from the user.
2. Backend: Verify credentials against a database and if they're valid, create a signed token and return it in the response.
3. Secure connection: From this point on, the frontend will send the token on every request and the backend will validate it to ensure it's a valid and authenticated user.
4. Secured best practices: Ensure your passwords are hashed (e.g., with bcrypt) and use HTTPS for a secured data transmission channel.

## What is the purpose of package.json in a Node.js project?
The package.json file in a Node.js project has multiple uses. It defines the project's metadata, like its name, version and description. It also lists the dependencies and devDependencies required to run or develop the application, as well as scripts for tasks like building, testing or running the app (and any custom script you'd like to add)

Finally, it sensures reproducible installations by allowing the npm install command to pull consistent dependencies, ensuring you can easily port your project into other systems.

## How would you connect a Node.js application to a database and perform basic CRUD operations?
In general terms, connecting to a datbase using Node.js requires the following steps:
1. INstall the DB driver.
2. Use the driver to connect to the database.
3. Use the returned connection object to send requests.

Of course, depending on the database enngine you decide to go with, there might be some slight, changes to those steps.

However, if we think about either MongoDB or PostgreDB, let's take a look at how to interact with them through Node.js:

Install the Database Driver

The first thing you gotta do, is install either the driver which will let you directly interact with the database, or an ORM, whichi will abstract that connection and give you a higher-level layer of abstraction.

Use the appropriate driver for your database.
- For MongoDB: `npm install mongoose`
- For PostgreSQL: `npm install pg`

Connect to the database

Now to connect to the actual database, you'll have to adapt the code based on the connection method you're using. Let's take a closer look at how to connect either to MongoDB or PostgreDB.

### MongoDB:
```
const mongoose = require('mongoose');
mognoose.connect('mongodb://localhost:27017/mydb', { useNewUrlParser: true, useUnifiedTopology: true });
```

### PostgreSQL:
```
const { Pool } = require('pg');
const pool = new Pool({ user: 'user', host: 'localhost', database: 'mydb', password: 'password', port: 5432 });
```

Perform CRUD operations

For the CRUD (Create, Read, Update & Delete), the code is going to change based on the technology you're using. Here in our examples, we have one that's using an ORM which means we have an abstraction layer on top of the native query language, and then we also have a simple SQL driver, which means we have to directly write SQL queries.

### Create operation:
### MongoDB:
```
const User = mongoose.model('User', { name: String });
User.create({ name: 'John Doe' });
```
### PostgreSQL:
```
pool.query('INSERT INTO users (name) VALUES ($1)', ['John Doe']);
```
### Read operation:
### MongoDB:
```
User.find({}, (err, users) => console.log(users));
```
### PostgreSQL:
```
pool.query('SELECT * FROM users', (err, res) => console.log(res.rows));
```
### Update operation:
### MongoDB:
```
User.updateOne({ name: 'John Doe' }, { name: 'Jane Doe' });
```
### PostgreSQL:
```
pool.query('UPDATE users SET name = $1 WHERE name = $2', ['Jane Doe', 'John Doe']);
```
### Delete operation:
### MongoDB:
```
User.deleteOne({ name: 'Jane Doe' });
```
### PostgreSQL:
```
pool.query('DELETE FROM users WHERE name = $1', ['Jane Doe']);
```
## What are environment variables, and how are they used?
Environment variables store configuration values (e.g., API keys, dastabase URLs) outside the codebase. This is important for two main reasons:
1. Security. By extracting these values (which tend to be private) from the codebase, you avoid potential code leaks from becoming a bigger security problem.
2. More flexible deployments. If these values need to change, by having them as environment variables you don't need to re-deploy your code, you just need to reload those values (either by restarting the app, or hot reloading the values from a file).

For the actual implementation, one might use something like the `dotenv` module, which loads environment variables from a .env file in the local folder of the project, or interact with a secret manager, such as AWS Secret Manager which stores these values externally in a secure storage.
