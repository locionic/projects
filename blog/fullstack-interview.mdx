---
title: Fullstack Interview
date: '2025-03-20'
tags: ['Fullstack', 'Interview']
draft: false
summary: Top 50 Full Stack Developer Interview Questions 
---
# Beginner
## What is full-stack development?
**Full-stack development** refers to the practice of building and maintaining both the frontend and backend of a web application or web service. A full-stack developer works across all layers of the application, ensuring seamless functionality from the user interface to the server and database.

Key aspects of a full-stack development include:
- **Frontend Development**: involves creating the parts of the application that users interact with directly, such as buttons, forms, and layouts. Tools and technologies often used include **HTML, CSS, JavaScript**, and frameworks like React, ANgular, or Vue.js. This may also include building Progressive Web APps (PWAs) for enhanced user experiences.
- **Backend Development**: Focuses on server-side logic, databases and APIs that power the frontend. COmmon programming languages for backend development include **Python, Java, Node.js, PHP**.
- **Databases and Storage**: Managing data through relational databases (e.g., MySQL, PostgreSQL) or non-relational databases (e.g., MongoDB, Redis).
- **DevOps and Deployment**: Setting up hosting environments, CI/CD pipelines, and handling cloud services to deploy and maintain applications.

Full-stack developers are valued for their versatility and and ability to understand how different components of a web application interact, making them crucial for delivering well-rounded, functional products.

## Explain the difference between lcient-side and server-side programming
The **client-side** and **server-side** refer to two distinct parts of a **web application** that work together to deliver functionality to users. Understanding their roles is essential for building efficient and responsive applications.

### Client-side
- **What it ddoes**: this is the part of the application that runs in the user's browser. It handles user interfaces and teractions, allowing users to see and interact with the applictaion.
- ** Key characteristics:
  - Executes **JavaScript code** directly in the browser to handle tasks like form validation, animations and dynamic content updates (through DOM - updates)
  - Manages rendering of HTML and CSS for a seamless visual experience.
  - Often communicates with the server via **REST** (Representational State Transfer) APIs to fetch or send data asynchronously.
- **Examples**:
  - Clicking a button that triggers a JavaScript function to show a popup
  - Fetching additional items on a page using fetch() or axios without a full page reload.
### Server-side
- **What it does**: this part operates on the server and processes requests from the client, performing tasks like database queries, busniness logic and serving responses.
- **Key characteristics**:
  - Executes server-side programming languages like Python, Java or Node.js
  - Handles sensitive operations like authentication and data storage securely.
  - Sends data to the client in structured formats (e.g., JSON) via REST APIs for rendering
- **Examples:
  - Processing a login request by verifying credentials in a database.
  - Returning a list of products in JSON format for the client to display dynamically.
##  What is the purpose of HTML, CSS and JavaScript in web development?
- HTML: Defines the structure and content of a webpage.
- CSS: Styles the webpage (colors, layout, fonts).
- JavaScript: Adds interactivity and dynamic behavior to the webpage.
## What is a REST API, and why is it used?
A REST API (Representational State Transfer APplication Programming Interface) is a standarized way for applications to communicate over HTTP by following a set of principles. It allows clients (like web browsers or mobile apps) to interact with servers to perform operations like fetching or modifying data.
### Key features of a REST API:
1. Stateless Communication: each request from the client to the server must contain all the information needed for the server to process it with no reliance on stored session data.
2. Resource-Based: Data annd functionality are treated as "resources" accessed using endpoints (URLs).
  - Example: `/users` to get a list of users, `/users/1` to access a specific user.
3. HTTP methods: REST APIs use HTTP methods to define actions:
  - GET: Retrieve data
  - POST: create new resources
  - PUT: update existing resources
  - DELETE: Remove resources
4. Structured Responses: Data is typically returned in a lightweight format like JSON or XML
### Why is it used?
  - Interoperability: REST APIs enable communication between different systems and playforms, making them ideal for building web services.
  - Scalability: they are stateless, allowing them to handle more traffic with horizontal scaling.
  - Ease of use: clear structure and standard conventions make it easy for developers to understand and implement.
  - Flexibility: Suitable for a variety of clients, from web applications to mobile and IoT devices.
## Explain the difference between GET and POST HTTP methods
While there is no hard rule stating these methods need to be used in a very specific way, the currently accepted standard, says that:
- GET: Retrieves data from a server (read-only).
- POST: sends data to the server to create or update resources.
## How do you include CSS in an HTML document?
There are two main ways to include CSS into your HTML, you can either do it "inline" or you can do it with the "style" tag.

Inline: Add `style` directly in an HTML element.
```html
<p style="color: red;">Hello</p>
```
Internal: use a `<style>` tag in the `<head>`
```html
<style>
p { color: red; }
</style>
```
External: Link a CSS file using `<link>` in the `<head>`
```html
<link rel="stylesheet" hred="styles.css">
```
## What is the purpose of the div and span tags in HTML?
- `<div>`: this is block-level element that groups other block-level elements (layout or sections) together. It's quite useful for layout definition.
- `<span>`: This inline element is greate for grouping together other inline elements, such as text nodes. Because the `<span>` has no structural impact on the content when used, it's perfect for styling text (or even sections of a larger text) without visually affecting it (other than the actual CSS applied).
## What are CSS selectors, and can oyu name a few types?
CSS selectors are patterns used to select and style specific elements in an HTML document. They define which elements a set of CSS rules should apply to, making them a fundamental part of designing the appearance of web applications and user interfaces.

Why CSS selectors matter

Selectors allow you to target elements precisely, enabling you to control layout, colors, fonts, and other visual aspects of you website. They are essential for creating strucrued and maintainable CSS code.

There are different types of selectors, categorized based on what they target:
- Elements: These selectors reference a specific type of element, and affect all instances of that element throughout the page. Example: `p{}`
- Classes: these selectors only affect those elements that have a matching class. They're greate to target large groups of elements of the same type, without affecting the entire set. Example: `.my-class{}`
- ID: ID-level selectors affect only one element (as IDs can only be used on a single element). They're greate when you have a single element that breaks the pattern from the rest of the group. Example `#my-id{}`
- Attribute: Attribute-level selectors target elements based on the value of their attributes. They're greate for the cases where you have to dynamically highlight elements. Example: `[type="text"]{}`
- Descendant: Another way to target other elements is to target them based on the parent element. This method works with any combination of the above, so you can potentially target elements using a specific class that are descendants of an elements with a specific attribute value (or any other combination you can think of). Example: `div p {}`

When to use selectors:
- Use type selectors for global styling
- Use class selectors for reusable styles across multiple elements
- Use ID selectors sparingly for unique elements
- Combine selectors for granular control and better maintainability

CSS selectors give you the power to control every aspect of your web application's design, ensuring that your user interfaces are consistent, visually appealing, and responsive

## How does JavaScript manipulate the DOM?
JavaScript accesses and modifies the DOM using methods like:
- Get elements: `document.getElementById("id")`, `querySelector(".class")`.
- Modify content: `element.innerHTML = "New content"`.
- Change styles: `element.style.color = "blue"`.
- Add/remove elements: `appendChild()`, `removeChild()`.

## What is the difference between == and === in JavaScript?
- `==`: Compares values with each other directly, performing type conversion if required first (example: `'5' == 5` -> `true).
- `===`: This operator strictly compares values and types with each other. There is no type conversion performed with this operator. For example, if you try to compare a string and a number, the result will always be false no matter what: `'5' === 5` -> `false`.
## What is the difference between relational and non-relational databases?
- Relational: Stores data in structured tables with rows and columns (e.g., MySQL, PostgreSQL). Good for relationships and complex queries.
- Non-relational: Stores data in flexible formats like documents, key-value pairs, or graphs (e.g., MongoDB, Redis). Better for unstructured or hierarchical data.
## How would you handle user authentication in a web application?
There are many ways to handle authentication, from simple auth, all the way to oAuth. The right option depends on your particular business needs.

A classical example is using JWT for authenticating a website with a RESTful API using the following process:
1. Frontend: Present a login form to collect credentials from the user.
2. Backend: Verify credentials against a database and if they're valid, create a signed token and return it in the response.
3. Secure connection: From this point on, the frontend will send the token on every request and the backend will validate it to ensure it's a valid and authenticated user.
4. Secured best practices: Ensure your passwords are hashed (e.g., with bcrypt) and use HTTPS for a secured data transmission channel.

## What is the purpose of package.json in a Node.js project?
The package.json file in a Node.js project has multiple uses. It defines the project's metadata, like its name, version and description. It also lists the dependencies and devDependencies required to run or develop the application, as well as scripts for tasks like building, testing or running the app (and any custom script you'd like to add)

Finally, it sensures reproducible installations by allowing the npm install command to pull consistent dependencies, ensuring you can easily port your project into other systems.

## How would you connect a Node.js application to a database and perform basic CRUD operations?
In general terms, connecting to a datbase using Node.js requires the following steps:
1. INstall the DB driver.
2. Use the driver to connect to the database.
3. Use the returned connection object to send requests.

Of course, depending on the database enngine you decide to go with, there might be some slight, changes to those steps.

However, if we think about either MongoDB or PostgreDB, let's take a look at how to interact with them through Node.js:

Install the Database Driver

The first thing you gotta do, is install either the driver which will let you directly interact with the database, or an ORM, whichi will abstract that connection and give you a higher-level layer of abstraction.

Use the appropriate driver for your database.
- For MongoDB: `npm install mongoose`
- For PostgreSQL: `npm install pg`

Connect to the database

Now to connect to the actual database, you'll have to adapt the code based on the connection method you're using. Let's take a closer look at how to connect either to MongoDB or PostgreDB.

### MongoDB:
```
const mongoose = require('mongoose');
mognoose.connect('mongodb://localhost:27017/mydb', { useNewUrlParser: true, useUnifiedTopology: true });
```

### PostgreSQL:
```
const { Pool } = require('pg');
const pool = new Pool({ user: 'user', host: 'localhost', database: 'mydb', password: 'password', port: 5432 });
```

Perform CRUD operations

For the CRUD (Create, Read, Update & Delete), the code is going to change based on the technology you're using. Here in our examples, we have one that's using an ORM which means we have an abstraction layer on top of the native query language, and then we also have a simple SQL driver, which means we have to directly write SQL queries.

### Create operation:
### MongoDB:
```
const User = mongoose.model('User', { name: String });
User.create({ name: 'John Doe' });
```
### PostgreSQL:
```
pool.query('INSERT INTO users (name) VALUES ($1)', ['John Doe']);
```
### Read operation:
### MongoDB:
```
User.find({}, (err, users) => console.log(users));
```
### PostgreSQL:
```
pool.query('SELECT * FROM users', (err, res) => console.log(res.rows));
```
### Update operation:
### MongoDB:
```
User.updateOne({ name: 'John Doe' }, { name: 'Jane Doe' });
```
### PostgreSQL:
```
pool.query('UPDATE users SET name = $1 WHERE name = $2', ['Jane Doe', 'John Doe']);
```
### Delete operation:
### MongoDB:
```
User.deleteOne({ name: 'Jane Doe' });
```
### PostgreSQL:
```
pool.query('DELETE FROM users WHERE name = $1', ['Jane Doe']);
```
## What are environment variables, and how are they used?
Environment variables store configuration values (e.g., API keys, dastabase URLs) outside the codebase. This is important for two main reasons:
1. Security. By extracting these values (which tend to be private) from the codebase, you avoid potential code leaks from becoming a bigger security problem.
2. More flexible deployments. If these values need to change, by having them as environment variables you don't need to re-deploy your code, you just need to reload those values (either by restarting the app, or hot reloading the values from a file).

For the actual implementation, one might use something like the `dotenv` module, which loads environment variables from a .env file in the local folder of the project, or interact with a secret manager, such as AWS Secret Manager which stores these values externally in a secure storage.

# Intermediate Level

## Explain the concept of responsive design. How would you implement it?
Responsive design ensures a website looks good on all devices by adapting its layout to different screen sizes.

To help ensure this, you can use flexible grids (either `CSS grid` or `Flexbox`).

You will also have to apply media queries which help set breakpoints where the different styles need to be applied based on the width of the window:

```
@media (max-width: 768px) {
  .container {
    flex-direction: column;
 }
}
```

You can also use relative units (%, em, rem) instead of fixed units (px) to ensure the values automatically adapt to the size of the container.

## What is the difference between Flexbox and CSS grid?
Flexbox: designed for one-dimensional lasyouts (row or column). Best of aligning items within a container. Example use cases: navigation bars or centering elements.

CSS grid: designed for two-dimensional layouts (rows and columns). best for creating complex grid-based layouts. Example use cases: Ful-page layouts or dashboards.

## What are React hooks, and why are they used?
React hooks are functions that let you use state and other React features in functional components.

With hooks you can simplify state and lifecycle management without needing class components. They also enable code reuse through custom hooks.

### Examples of different hooks:
- `useState` for managing state
- `useEffect` for handling side effects (e.g., fetching data)
- `useContext` for global state

## How does state management work in React applications?
In React you have two different ways to handle state, depending on the scope of the data inside that state.

If the scope is local, then you can handle it through a simple `useState` hook inside the component itself.

If on the other hand, you need to store a global state which is accessible for many components, then you can use something like the `Context API` or specific state libraries like Redux, MobX or Zustand.

The way state handling works in React (in general terms) works lik this:
- State is updated via actions (e.g., event handlers)
- Updated state triggers re-renders to reflect changes in the UI
- Avoid excessive re-renders by optimizing context or using memoization (React.memo, useMemo)

## Explain how you would optimize the performance of a React app
The performance of a React application can be affected by multiple aspects, but some of the most common ones and their way to fix them are:
1. Reduce Re-renders:
- Use `React.memo` and `useCallback` to avoid unnecessary updates.
- Split large components into smaller, focused componenets.
2. Lazy loading: load componenets or routes on demand using `React.lazy` and `Suspense`.
3. **Efficient State Management**: Keep state local where possible and avoid overusing global state.
4. **Minimize DOM updates**: Use keys in lists and avoid deeply nested props/state updates.
5. **Code splitting**: use webpack or tools like `react-loadable` to split the bundle.
6. **Profile and Debug**: Use React Developer Tools to identify bottlenecks.

## What is middleware in the context of Node.js and Express?
Middleware in Express is a function that processes requests and responses in the app's request-response cycle. It can be used to modify request/response objects adding extra information or removing unnecessary data, it can execute code (like logging, parsing JSON, etc) and it can also end the request-response cycle, allowing it to short-circuit the process and return a different response (commonly used to handle invalid or unauthorized requests).

# Example:
```javascript
app.use((req, res, next) => {
  console.log('Middleware triggered');
  next();
});
```

## How do you manage asynchronous code in JavaScript?
JavaScript handles asynchronous operations, like fetching data from an API or reading files, through different paradigms: callbacks, promises and async/await. Each offers unique advantages and challenges. Here's a detailed look:
1. Callbacks
### What it is:
A callback is a function passed as asn agrument to another function to be executed later, usually after an asynchronous task completes.
### Example:
```javascript
fs.readFile('file.txt', (err, data) => {
  if (err) {
    console.error('Error reading file: ', err);
    return;
  }
  console.log('FIle content: ', data.toString());
});
```
### Callback heel: As tasks become more complex, nesting callbacks leads to hard-to-read and maintable code.
```javascript
doTask1(() => {
  doTask2(() => {
    doTask3(() => {
      console.log('All tasks done!');
    });
  });
});
```
2. Promises
### What it is:
A promise represents a value that may be available now, in the future, or never usually coming as a result of an asynchronouss operation. It provides a cleaner way to handle asynchronous operations, chaining actions which `.then()` and catching errors withc `.catch()`
### Example:
```javascript
fetch('https://api.example.com/data')
  .then((response) => response.json())
  .then((data) => {
    console.log('Fetched data: ', data);
  })
  .catch((error) => {
    console.error('Error fetching data: ', error);
  });
```

### Advantages:
- Eliminates deeply nested callbacks.
- Provides a clearer structure for handling asynchronous workflows.
3. Async/Await
### What it is:
Async/await is built on promises but provides a more synchronous and readable syntax for managing this type of code.

Functions declared with `async` automatically return a promise, and the `await` keyword pauses execution until a promise resolves.

### Example:
```javascript
const fetchData = async () => {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log('Fetched data:', data);
  } catch (error) {
    console.error('Error fetching data:', error);
  }
};

fetchData();
```

### Advantages:
- Reads like asynchronous code, making it easier to understand.
- Simplifiers error handling with `try/catch` blocks.

### Explain how relational databases handle relationships

1. One-to-Many: One record in a table relates to multiple records in another. Handled via foreign keys. Example: A `user` has many `posts`
2. Many-to-Many: Requires a join table to link records from two tables. Example: `students` and `courses` with an intermediary `enrollmenets` table.
3. Primary/Foreign Keys: Establish links between tables for querying and ensuring data consistency.

### How would you implement pagination in a REST API?
Adding pagination to a RESTful API can be done in multiple ways, but assuming a standard implementation, the best option is to go with query parameters.

**Query Parameters**: Using `limit` and `offset` (or `page` and `size`).
```
GET /api/items?limit=10&offset=20
```

**Backend implementation**:

In the backend, we're turn those query params into something like:
```
SELECT * FROM items LIMIT 10 OFFSZET 20;
```

**In code:
```
const items = await db.find().skip(offset).limit(limit);
res.json({ data: items });
```

Metadata:

Include total count and current page in the response for better UX:
```
{ 
  "data": [...], 
  "total": 100,
  "page": 3,
  "size": 10 
}
```

## Describe how you would secure an API using authentication and authorization techniques

Rather than overlapping each other, authorization and authentication reference two very distinct stages of security with in your app

Authentication

On one side, we have authentication, in chrrge of verifying the user identity. You can use tokens (eg., JWT, OAuth) or sessions for this.

Example: Validate a JWT sent in headers:
```
const token = req.headers['authorization'];
jwt.verify(token, secretKey, (err, decoded) => { ... });
```

Authorization

Once authenticated, users need to be authorized to access the resources. For this to work, you'll need to defien roles and permissions for your users.

Middleware example:
```
app.use((req, res, next) => {
  if (req.user.role !== 'admin') return res.status(403).send('Forbidden');
  next();
});
```

Best practices:
- Use HTTPS to ensure a secure channel between the browser and the server.
- Validate input to prevent injection attacks.
- Rate-limit API requests to avoid having your APIs overwhelmed by potential attackers.
- Store sensitive data securely (e.g., hashed passwords).

## Explain the purpose of a version

Purpose: Version cotrol tracks changes in code, enables collaboration, and allows reverting to previous versions.

### Git workflow example:
1. Clone the repository: `git clone <repo_url>`
2. Create a branch: `git checkout -b feature-branch`
3. Make changes and stage them: `git add .`
4. Commit changes: `git commit -m "Add feature"`
5. Push to the remote: `git push origin feature-branch`
6. Create a pull request for review
7. Merge the branch into the main branch after approval

## What are Websockets and how do they differ from HTTP requests?

**WebSockets**: A protocol for full-duplex communication between client and server over a single persistent connection.

**Difference**:
- HTTP: Request-response model; client initiates every interaction.
- WebSockets: persistent, allowing real-time, two-way communication (e.g., live chat, notifications).

Example:
- HTTP: send a request for new messages repeatedly (polling)
- WebSocket: server pushes new messages as they arrive

## Describe the concept of MVC architecture
MVC is a design patttern for organizing code in three layers:
1. Model: Handles data and business logic (e.g., database interactions)
2. View: displays data to users (e.g., HTML, templates)
3. Controller: Manages user input and communicates between Model and View

### Flow:
- User interacts with the View -> Controller provesses input -> Updates the Model -> Changes are reflected in the View

## What is CORS and how do you handle it in a web application?
Cors (Cross - origin resource sharing) controls access to resources from a different origin (domain, porotocol or port)

Handling CORS:

Backend: Set headers to allow specific origins

Example in Express:
```
const cors = require('cors');
app.use(cors({ origin: 'https://example.com' }));
```

Frontend: Proxy API requests to avoid CORS issues during development

## How do you use Postman for testing APIs?
1. Create a request: enter the API endpoint, method (GET, POST, etc.), and headers
2. Send data:
  - Add query params, body (JSON, form data), or headers
3. Send request: Click "send" to view the response

Assertions: Use the tests tab to write scripts (JavaScript) for automated validation of responses

Example:
```
pm.test("Status is 200", () => {
  pm.response.to.have.status(200);
});
```
4. Collections: Group requests for testing workflows or environments

# Advanced
## How would you deploy a full-stack application to a cloud provider?
A full-stack application includes one or more web pages, a backend (which usually involve microservices) and some sort of storage engine (i.e a database).

To deploy all of that together, you have to:
1. Prepare the application: build the frontend (e.g., using `npm run build`). Ensure the back-end is production-ready (e.g., environment variables, database setup)
2. Deploy frontend: push the code into the servers, usually something like AWS S3, GCP cloud storage, or firebase hosting to host static files. Configure a CDN (e.g., CloudFront) if needed for static content
3. Deploy backend: use cloud services like AWS EC2, GCP compute engine, or a managed platform like AWS Elastic Beanstalk. Set up environment variables and connect to the database (e.g., RDS, Cloud SQL)
4. Database: use a managed database service (e.g., RDS, Firestore) for scalability, or deploy an on-prem database on your server
5. DNS and SSL: configure a custom domain and HTTPS using AWS Route 53, GCP Domains, or another provider.

## What is the purpose of a build tool like Webpack or Vite?
Build tools bundle, optimize and prepare your code for deployment.

Key Functions:
- Bundle JavaScript, CSS and other assets.
- Minify and optimize files for faster loading.
- Enable features like hot module replacement (during development).
- Handle modern JavaScript (transpile ES6+ to older versions).

## How do you debug an issue that occurs in both the frontend and backend?
1. Reproduce the issue: identify when and where it happens.
2. Frontend debugging:
  - Use browser DevTools to inspect network requests (e.g., check HTTP status codes, payloads).
  - Check console errors for clues.
3. Backend debugging:
  - Check server logs for errors or trace logs for the request.
  - Add breakpoints or use a debugger (e.g., Node.js inspector).
4. Communication POint: verify API endpoints, payload structure, and data format.
5. End-to-End testing: test the workflow with tools like Postman to isolate the layer causing issues.
